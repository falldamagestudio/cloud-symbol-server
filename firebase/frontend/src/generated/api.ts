/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Symbol Server Admin API
 * This is the API that is used to manage stores and uploads in Cloud Symbol Server
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreateStoreUploadRequest
 */
export interface CreateStoreUploadRequest {
    /**
     * When present and set to true, the client will provide progress updates; Legacy clients will create an upload, then upload the required files to GCS, without progress/completion callbacks
     * @type {boolean}
     * @memberof CreateStoreUploadRequest
     */
    'useProgressApi'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateStoreUploadRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStoreUploadRequest
     */
    'buildId'?: string;
    /**
     * 
     * @type {Array<UploadFileRequest>}
     * @memberof CreateStoreUploadRequest
     */
    'files'?: Array<UploadFileRequest>;
}
/**
 * 
 * @export
 * @interface CreateStoreUploadResponse
 */
export interface CreateStoreUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateStoreUploadResponse
     */
    'id'?: string;
    /**
     * 
     * @type {Array<UploadFileResponse>}
     * @memberof CreateStoreUploadResponse
     */
    'files'?: Array<UploadFileResponse>;
}
/**
 * 
 * @export
 * @interface CreateTokenResponse
 */
export interface CreateTokenResponse {
    /**
     * Personal Access Token
     * @type {string}
     * @memberof CreateTokenResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface GetFileResponse
 */
export interface GetFileResponse {
    /**
     * 
     * @type {string}
     * @memberof GetFileResponse
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFileResponse
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetFileResponse
     */
    'status'?: GetFileResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetFileResponseStatusEnum {
    Unknown = 'unknown',
    AlreadyPresent = 'already_present',
    Pending = 'pending',
    Completed = 'completed',
    Aborted = 'aborted',
    Expired = 'expired'
}

/**
 * 
 * @export
 * @interface GetStoreFileIdsResponse
 */
export interface GetStoreFileIdsResponse extends Array<string> {
}
/**
 * 
 * @export
 * @interface GetStoreUploadIdsResponse
 */
export interface GetStoreUploadIdsResponse extends Array<string> {
}
/**
 * 
 * @export
 * @interface GetStoreUploadResponse
 */
export interface GetStoreUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof GetStoreUploadResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetStoreUploadResponse
     */
    'buildId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetStoreUploadResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Array<GetFileResponse>}
     * @memberof GetStoreUploadResponse
     */
    'files'?: Array<GetFileResponse>;
    /**
     * 
     * @type {string}
     * @memberof GetStoreUploadResponse
     */
    'status'?: GetStoreUploadResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GetStoreUploadResponseStatusEnum {
    Unknown = 'unknown',
    InProgress = 'in_progress',
    Completed = 'completed',
    Aborted = 'aborted',
    Expired = 'expired'
}

/**
 * 
 * @export
 * @interface GetStoresResponse
 */
export interface GetStoresResponse extends Array<string> {
}
/**
 * 
 * @export
 * @interface GetTokenResponse
 */
export interface GetTokenResponse {
    /**
     * Personal Access Token This token can be used for authentication when accessing non-token related APIs
     * @type {string}
     * @memberof GetTokenResponse
     */
    'token'?: string;
    /**
     * Textual description of token Users fill this in to remind themselves the purpose of a token and/or where it is used
     * @type {string}
     * @memberof GetTokenResponse
     */
    'description'?: string;
    /**
     * Creation timestamp, in RFC3339 format
     * @type {string}
     * @memberof GetTokenResponse
     */
    'creationTimestamp'?: string;
}
/**
 * 
 * @export
 * @interface GetTokensResponse
 */
export interface GetTokensResponse extends Array<GetTokenResponse> {
}
/**
 * 
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTokenRequest
 */
export interface UpdateTokenRequest {
    /**
     * Textual description of token Users fill this in to remind themselves the purpose of a token and/or where it is used
     * @type {string}
     * @memberof UpdateTokenRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UploadFileRequest
 */
export interface UploadFileRequest {
    /**
     * 
     * @type {string}
     * @memberof UploadFileRequest
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileRequest
     */
    'hash'?: string;
}
/**
 * 
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponse
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadFileResponse
     */
    'hash'?: string;
    /**
     * Short-lived signed URL where the client should upload the file to, or blank if the file already exists in the storage backend
     * @type {string}
     * @memberof UploadFileResponse
     */
    'url'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new store
         * @param {string} storeId ID of store to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStore: async (storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('createStore', 'storeId', storeId)
            const localVarPath = `/stores/{storeId}`
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a new upload
         * @param {string} storeId ID of the store containing the upload
         * @param {CreateStoreUploadRequest} createStoreUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStoreUpload: async (storeId: string, createStoreUploadRequest: CreateStoreUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('createStoreUpload', 'storeId', storeId)
            // verify required parameter 'createStoreUploadRequest' is not null or undefined
            assertParamExists('createStoreUpload', 'createStoreUploadRequest', createStoreUploadRequest)
            const localVarPath = `/stores/{storeId}/uploads`
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStoreUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new token for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an existing store
         * @param {string} storeId ID of store to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStore: async (storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('deleteStore', 'storeId', storeId)
            const localVarPath = `/stores/{storeId}`
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a token for current user
         * @param {string} token ID of the token to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteToken', 'token', token)
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expire store upload and consider files for GC
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireStoreUpload: async (uploadId: string, storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('expireStoreUpload', 'uploadId', uploadId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('expireStoreUpload', 'storeId', storeId)
            const localVarPath = `/stores/{storeId}/uploads/{uploadId}/expire`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a list of all files in store
         * @param {string} storeId ID of the store containing the files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreFileIds: async (storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('getStoreFileIds', 'storeId', storeId)
            const localVarPath = `/stores/{storeId}/files`
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch an upload
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreUpload: async (uploadId: string, storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('getStoreUpload', 'uploadId', uploadId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('getStoreUpload', 'storeId', storeId)
            const localVarPath = `/stores/{storeId}/uploads/{uploadId}`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a list of all uploads in store
         * @param {string} storeId ID of the store containing the uploads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreUploadIds: async (storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('getStoreUploadIds', 'storeId', storeId)
            const localVarPath = `/stores/{storeId}/uploads`
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a list of all stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStores: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a token for current user
         * @param {string} token ID of the token to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getToken', 'token', token)
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a list of all tokens for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an upload as aborted
         * @param {string} uploadId ID of the upload to mark as aborted
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStoreUploadAborted: async (uploadId: string, storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('markStoreUploadAborted', 'uploadId', uploadId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('markStoreUploadAborted', 'storeId', storeId)
            const localVarPath = `/stores/{storeId}/uploads/{uploadId}/aborted`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark an upload as completed
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStoreUploadCompleted: async (uploadId: string, storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('markStoreUploadCompleted', 'uploadId', uploadId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('markStoreUploadCompleted', 'storeId', storeId)
            const localVarPath = `/stores/{storeId}/uploads/{uploadId}/completed`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark a file within an upload as uploaded
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {number} fileId Index of the file within the upload that should be marked as uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStoreUploadFileUploaded: async (uploadId: string, storeId: string, fileId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('markStoreUploadFileUploaded', 'uploadId', uploadId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('markStoreUploadFileUploaded', 'storeId', storeId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('markStoreUploadFileUploaded', 'fileId', fileId)
            const localVarPath = `/stores/{storeId}/uploads/{uploadId}/files/{fileId}/uploaded`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update details of a token for current user
         * @param {string} token ID of the token to update
         * @param {UpdateTokenRequest} updateTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToken: async (token: string, updateTokenRequest: UpdateTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateToken', 'token', token)
            // verify required parameter 'updateTokenRequest' is not null or undefined
            assertParamExists('updateToken', 'updateTokenRequest', updateTokenRequest)
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication emailAndPat required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new store
         * @param {string} storeId ID of store to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStore(storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStore(storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a new upload
         * @param {string} storeId ID of the store containing the upload
         * @param {CreateStoreUploadRequest} createStoreUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStoreUpload(storeId: string, createStoreUploadRequest: CreateStoreUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateStoreUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStoreUpload(storeId, createStoreUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new token for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an existing store
         * @param {string} storeId ID of store to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStore(storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStore(storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a token for current user
         * @param {string} token ID of the token to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Expire store upload and consider files for GC
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expireStoreUpload(uploadId: string, storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expireStoreUpload(uploadId, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a list of all files in store
         * @param {string} storeId ID of the store containing the files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreFileIds(storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStoreFileIdsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreFileIds(storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch an upload
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreUpload(uploadId: string, storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStoreUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreUpload(uploadId, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a list of all uploads in store
         * @param {string} storeId ID of the store containing the uploads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoreUploadIds(storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStoreUploadIdsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoreUploadIds(storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a list of all stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStores(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStoresResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStores(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a token for current user
         * @param {string} token ID of the token to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a list of all tokens for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark an upload as aborted
         * @param {string} uploadId ID of the upload to mark as aborted
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markStoreUploadAborted(uploadId: string, storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markStoreUploadAborted(uploadId, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark an upload as completed
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markStoreUploadCompleted(uploadId: string, storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markStoreUploadCompleted(uploadId, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark a file within an upload as uploaded
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {number} fileId Index of the file within the upload that should be marked as uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markStoreUploadFileUploaded(uploadId: string, storeId: string, fileId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markStoreUploadFileUploaded(uploadId, storeId, fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update details of a token for current user
         * @param {string} token ID of the token to update
         * @param {UpdateTokenRequest} updateTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateToken(token: string, updateTokenRequest: UpdateTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateToken(token, updateTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new store
         * @param {string} storeId ID of store to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStore(storeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.createStore(storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a new upload
         * @param {string} storeId ID of the store containing the upload
         * @param {CreateStoreUploadRequest} createStoreUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStoreUpload(storeId: string, createStoreUploadRequest: CreateStoreUploadRequest, options?: any): AxiosPromise<CreateStoreUploadResponse> {
            return localVarFp.createStoreUpload(storeId, createStoreUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new token for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken(options?: any): AxiosPromise<CreateTokenResponse> {
            return localVarFp.createToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an existing store
         * @param {string} storeId ID of store to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStore(storeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStore(storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a token for current user
         * @param {string} token ID of the token to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Expire store upload and consider files for GC
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireStoreUpload(uploadId: string, storeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.expireStoreUpload(uploadId, storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a list of all files in store
         * @param {string} storeId ID of the store containing the files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreFileIds(storeId: string, options?: any): AxiosPromise<GetStoreFileIdsResponse> {
            return localVarFp.getStoreFileIds(storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch an upload
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreUpload(uploadId: string, storeId: string, options?: any): AxiosPromise<GetStoreUploadResponse> {
            return localVarFp.getStoreUpload(uploadId, storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a list of all uploads in store
         * @param {string} storeId ID of the store containing the uploads
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreUploadIds(storeId: string, options?: any): AxiosPromise<GetStoreUploadIdsResponse> {
            return localVarFp.getStoreUploadIds(storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a list of all stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStores(options?: any): AxiosPromise<GetStoresResponse> {
            return localVarFp.getStores(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a token for current user
         * @param {string} token ID of the token to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(token: string, options?: any): AxiosPromise<GetTokenResponse> {
            return localVarFp.getToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a list of all tokens for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options?: any): AxiosPromise<GetTokensResponse> {
            return localVarFp.getTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an upload as aborted
         * @param {string} uploadId ID of the upload to mark as aborted
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStoreUploadAborted(uploadId: string, storeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markStoreUploadAborted(uploadId, storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark an upload as completed
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStoreUploadCompleted(uploadId: string, storeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markStoreUploadCompleted(uploadId, storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark a file within an upload as uploaded
         * @param {string} uploadId ID of the upload to fetch
         * @param {string} storeId ID of the store containing the upload
         * @param {number} fileId Index of the file within the upload that should be marked as uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStoreUploadFileUploaded(uploadId: string, storeId: string, fileId: number, options?: any): AxiosPromise<void> {
            return localVarFp.markStoreUploadFileUploaded(uploadId, storeId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update details of a token for current user
         * @param {string} token ID of the token to update
         * @param {UpdateTokenRequest} updateTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToken(token: string, updateTokenRequest: UpdateTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateToken(token, updateTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Create a new store
     * @param {string} storeId ID of store to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createStore(storeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createStore(storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a new upload
     * @param {string} storeId ID of the store containing the upload
     * @param {CreateStoreUploadRequest} createStoreUploadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createStoreUpload(storeId: string, createStoreUploadRequest: CreateStoreUploadRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createStoreUpload(storeId, createStoreUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new token for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createToken(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an existing store
     * @param {string} storeId ID of store to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteStore(storeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteStore(storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a token for current user
     * @param {string} token ID of the token to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteToken(token: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Expire store upload and consider files for GC
     * @param {string} uploadId ID of the upload to fetch
     * @param {string} storeId ID of the store containing the upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public expireStoreUpload(uploadId: string, storeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).expireStoreUpload(uploadId, storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a list of all files in store
     * @param {string} storeId ID of the store containing the files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreFileIds(storeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreFileIds(storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch an upload
     * @param {string} uploadId ID of the upload to fetch
     * @param {string} storeId ID of the store containing the upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreUpload(uploadId: string, storeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreUpload(uploadId, storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a list of all uploads in store
     * @param {string} storeId ID of the store containing the uploads
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStoreUploadIds(storeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStoreUploadIds(storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a list of all stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStores(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStores(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a token for current user
     * @param {string} token ID of the token to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getToken(token: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a list of all tokens for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokens(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an upload as aborted
     * @param {string} uploadId ID of the upload to mark as aborted
     * @param {string} storeId ID of the store containing the upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public markStoreUploadAborted(uploadId: string, storeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).markStoreUploadAborted(uploadId, storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark an upload as completed
     * @param {string} uploadId ID of the upload to fetch
     * @param {string} storeId ID of the store containing the upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public markStoreUploadCompleted(uploadId: string, storeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).markStoreUploadCompleted(uploadId, storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark a file within an upload as uploaded
     * @param {string} uploadId ID of the upload to fetch
     * @param {string} storeId ID of the store containing the upload
     * @param {number} fileId Index of the file within the upload that should be marked as uploaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public markStoreUploadFileUploaded(uploadId: string, storeId: string, fileId: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).markStoreUploadFileUploaded(uploadId, storeId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update details of a token for current user
     * @param {string} token ID of the token to update
     * @param {UpdateTokenRequest} updateTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateToken(token: string, updateTokenRequest: UpdateTokenRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateToken(token, updateTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


